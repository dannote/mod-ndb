#include "mod_ndb.h"

COMPILER NSQL

cmd_parms *cmd;
config::dir *dir;
char *idxname, *idxtype, *rel_op;
char *tok_temp; 
char * copy_token() { 
  tok_temp = coco_string_create_char(t->val); 
  return tok_temp;
}
void free_token(char * &d) { coco_string_delete(d) ; }
void free_token()          { coco_string_delete(tok_temp); }

void index_col(char *name) {
  log_conf_debug(cmd->server,"SQL index rec %s:%s,%s", idxtype, idxname, name);
  const char *err = config::named_idx(idxtype, cmd, dir, idxname, name, rel_op);
  if(err) SemErr(err);
}
  
IGNORECASE
CHARACTERS
  char = 'a'..'z' + 'A'..'Z' + "0123456789!@#$%^_-".

TOKENS 
  DBName = char { char } CONTEXT(".").
  Name = char { char }.
  
COMMENTS FROM "/*" TO "*/"
IGNORE '\n' + '\r' + '\t' 

PRODUCTIONS
  NSQL = (SelectQuery | DeleteQuery) ";".
  DeleteQuery = "DELETE" FromClause WhereClause   (. dir->allow_delete = 1; .) .
  SelectQuery = SelectClause FromClause WhereClause .
  SelectClause = "SELECT" Column { "," Column } .
  FromClause = "FROM" TableSpec  .
  WhereClause = ("SCAN"  ScanSpec | "WHERE" IndexSpec) ["ORDER" OrderOp ] .

  Column = Name                   (. char *c_name  = copy_token();          .)
                                  (. char *c_alias = c_name;                .)
   [ "AS" Name                    (. c_alias = copy_token();                .)
   ]                              (. *dir->visible->new_item() = c_name;    .)
                                  (. *dir->aliases->new_item() = c_alias;   .) .

  TableSpec = 
    [ DBName                               (. dir->database = copy_token(); .)
     "." ] Name                               (. dir->table = copy_token(); .) .
  
  ScanSpec                                     (. dir->flag.table_scan = 1; .)
    = "TABLE" | "ordered" "index" Name           (. idxname = copy_token(); .)
                          (. config::ordered_index_scan(cmd, dir, idxname); .) .
                          
  IndexSpec                   
    = ( Name "key"             (. idxtype = "P"; idxname = "*Primary$Key*"; .)
      | "unique" "index" Name  (. idxtype = "U"; idxname = copy_token();    .)
    ) "=" VarList 
   |  "ordered" "index" Name   (. idxtype = "O"; idxname = copy_token();    .)
    relop VarList .

  OrderOp = "ASC"                                   (. index_col("[ASC]");  .)
   | "DESC"                                         (. index_col("[DESC]"); .) .
  
  VarList = var { "," var } .
  relop = ("=" | "<" | "<=" | ">" | ">=")       (. rel_op = copy_token();   .) .
  var = Name                                    (. index_col(copy_token()); .)
                                                (. free_token();            .) .
  
END NSQL .

/*       --- About memory leaks in the parser ---
  dir->xxx->new_item() = copy_token() is not a leak.
  dir->table or dir->database = copy_token() is not a leak.
  (Freeing the string in any of these cases would be a terrible bug.)
  Every index name assigned to idxname is a leak, but these cannot be 
  freed because they are used later in index_col(), and because idxname 
  sometimes points to string constants.
*/
