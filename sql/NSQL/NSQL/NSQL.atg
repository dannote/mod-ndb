$CX /* Compiler, NSQL++ */ 

//TODO?: Database, tables, columns can be up to 64 chars, might contain _ and $
//TODO?: Alias can be up to 256 chars
//TODO: MySQL names can start with a digit!? But cannot be all digits.
//DONE: Table name provided by Select Table.field should be included in From clause. 
//      e.g. select typ6.i from typ6; OK
//           select typ6.i from typ1; NOT

//DONE: AS before an alias can be optional

#include "mod_ndb.h"
#include "Tree.h"

#include <iostream>

COMPILER NSQL

	NSQLState *nsqlTree;        //Call getRoot to get a pointer to the syntax tree

IGNORECASE

CHARACTERS

  digit     = "0123456789" .     		  	  /* The set of all digits */  
  letter	= 'a'..'z' .
  eol       = '\n' .         				  /* Line feed character */ 
  noDigit   = ANY - digit .     			  /* Any character that is not a digit */ 
  InString  = ANY - '"' - eol .  			  /* Strings may not cross line boundaries */ 
  quote = '"'.
  escapechar = '\\' + quote.
  nonquote = ANY - '"' - escapechar.

TOKENS
	ident	=	letter {letter | digit | '_'}. 
	delete = 	"delete".
	select	=	"select".
	from	=	"from"	.
	where	=	"where" .
	order	=	"order" .
	o_or	=	"or"	.
	o_and	=	"and"	.
	qstring = quote { nonquote | '\\' escapechar } quote.
	number   = digit { digit } [ "." digit { digit } ] . 
	comma		= ',' .
	semicolon		= ';' .
	
COMMENTS FROM "//" TO eol 

PRODUCTIONS 

	NSQL
		=								
			Query	
		
	.
	
	Query	= 									(. QueryNode *root = new QueryNode(QUERY); 
												   bool shouldCloseRoot = true;
												nsqlTree->openNodeScope(root);
												try{ .)
			 (SelectQuery | DeleteQuery )
												(. }
												catch(ParseException & excp){
													if(shouldCloseRoot) { 
														nsqlTree->clearNodeScope(root);
														shouldCloseRoot = false;
													}
													else {
														nsqlTree->popNode();
													}
													delete root;
													throw;
												}
												
												if(shouldCloseRoot) { 
														nsqlTree->closeNodeScope(root,true);
												}
												
												
												.)
	.
												//http://dev.mysql.com/doc/refman/5.0/en/delete.html
	DeleteQuery
		= 	delete								(.	DeleteNode *deleteNode = new DeleteNode(DELETE);
												   bool shouldCloseDeleteNode = true;
												    nsqlTree->openNodeScope(deleteNode); 
													nsqlTree->closeNodeScope(deleteNode,true);
													shouldCloseDeleteNode = false;
	
												try{ .)
												
			FromClause
			[ WhereClause ]
			
		     semicolon
												(. }
												catch(ParseException & excp){
													if(shouldCloseDeleteNode) { 
														nsqlTree->clearNodeScope(deleteNode);
														shouldCloseDeleteNode = false;
													}
													else {
														nsqlTree->popNode();
													}
													delete deleteNode;
													throw;
												}
												
												if(shouldCloseDeleteNode) { 
														nsqlTree->closeNodeScope(deleteNode,true);
												}
																							
												.)
	.
	
	SelectQuery							
		= SelectClause
		  FromClause
		  [ WhereClause ]
		  [ OrderClause ]
		  semicolon
	 .
	 
	SelectClause
		=  select								(. SelectNode *select = new SelectNode(SELECT);
												bool shouldCloseSelectNode = true;
												nsqlTree->openNodeScope(select);
												try{ .)	
		   ( SelectList
		   	|
			"*"									(. StarNode *star = new StarNode(STAR);
												nsqlTree->openNodeScope(star); 
												nsqlTree->closeNodeScope(star,true);.)
		   )
		  										(. }
												catch(ParseException & excp){
													if(shouldCloseSelectNode) { 
														nsqlTree->clearNodeScope(select);
														shouldCloseSelectNode = false;
													}
													else {
														nsqlTree->popNode();
													}
													delete select;
													throw;
												}
												if(shouldCloseSelectNode) { 
														nsqlTree->closeNodeScope(select,true);
												}  .)
	.	
	
	SelectList									
		= Field	
			{ 
				comma Field
			} 
	.
	
	Field										(. char * value, * value1 = NULL;.)
		= 
		  Identifier<value> [ "." Identifier<value1> ]
		  										(. FieldNode *field = new FieldNode(FIELD);
												  nsqlTree->openNodeScope(field);
												  bool shouldCloseField = true;
												  if (value1 != NULL) {
												  	field->setTable(value);
												  	field->setName(value1);
												  }
												  else{
												  	field->setName(value);
												  }
												  	 
												  try{ .)
		[ ["as"]
		 Identifier<value>						(. field->setAlias(value); .)
		]										(. }
												catch(ParseException & excp){
													if(shouldCloseField) { 
														nsqlTree->clearNodeScope(field);
														shouldCloseField = false;
													}
													else {
														nsqlTree->popNode();
													}
													delete field;
													throw;
												}
												if(shouldCloseField) { 
														nsqlTree->closeNodeScope(field,true);
												} 
												.)	
		
	.	
		
	Identifier<char* &v>
			=	ident							(.	v = coco_string_create_char(t->val); .)
	.
	
	
	OrderClause
		= order 								(.	OrderNode *order = new OrderNode(ORDER);
												nsqlTree->openNodeScope(order); .)
		("asc"									(. order->setAsc();				.) 
		| 
		"desc" 									(. order->setDesc();			.) 
		)
												(.	nsqlTree->closeNodeScope(order,true); .)
	.
	
	FromClause
		= from									(.	FromNode *from = new FromNode(FROM);
												nsqlTree->openNodeScope(from); 
												bool shouldCloseFrom = true;
												try{ .)
		  FromList 
		  										(.	}
												catch(ParseException & excp){
													if(shouldCloseFrom) { 
														nsqlTree->clearNodeScope(from);
														shouldCloseFrom = false;
													}
													else {
														nsqlTree->popNode();
													}
													delete from;
													throw;
												}
												if(shouldCloseFrom) { 
														nsqlTree->closeNodeScope(from,true);
												} 
												.)
	.
	
	FromList									
		= Table								//Placeholder for multiple table names
	.
	
	
	Table										(. char * value, *value1 = NULL;.)
		= Identifier<value> [ "." Identifier<value1> ]
												(. /*auto*/
												  TableNode *table = new TableNode(TABLE);
												  nsqlTree->openNodeScope(table);
												  bool shouldCloseTable = true;
												  /*end auto*/
												  if (value1 != NULL) {
												  	table->setDatabaseName(value);
												  	table->setName(value1);
												  }
												  else{
												  	table->setName(value);
												  }
												  /*auto*/ 
												  try{ 
												  /*end auto*/
												  .)
		[ ["as"]
		 Identifier<value>						(. table->setAlias(value); .)
		]										(.
												/*auto*/  
												}
												catch(ParseException & excp){
													if(shouldCloseTable) { 
														nsqlTree->clearNodeScope(table);
														shouldCloseTable = false;
													}
													else {
														nsqlTree->popNode();
													}
													delete table;
													throw;
												}
												if(shouldCloseTable) { 
														nsqlTree->closeNodeScope(table,true);
												} 
												/*end auto*/
												.)	
	.
		
	WhereClause
		= where									(.	WhereNode *where = new WhereNode(WHERE);
												nsqlTree->openNodeScope(where); 
												bool shouldCloseWhere = true;
												try {.)
		  (
		  	SelectCondition
		  	|
		  	IndexCondition					// Backward Compatibility
		  									// Relates to OneRowWhereClause in old grammar
		  									// Might depreciate
		  									// To support conditions using PRIMARY KEY and UNIQUE KEY 
		  )
		  										(.	}
												catch(ParseException & excp){
													if(shouldCloseWhere) { 
														nsqlTree->clearNodeScope(where);
														shouldCloseWhere = false;
													}
													else {
														nsqlTree->popNode();
													}
													delete where;
													throw;
												}
												if(shouldCloseWhere) { 
														nsqlTree->closeNodeScope(where,true);
												} .)
	.
	
// Backward compatibility	
	IndexCondition = 
		PrimaryKey |	UniqueIndex
	.
	
	PrimaryKey =
		"PRIMARY" "KEY"	"=" 					(.	// Create special ANDNode
													// Can have 1 to n EQNode children
													ANDNode *andNode = new ANDNode(AND);
		  											bool shouldCloseANDNode = true;
												nsqlTree->openNodeScope(andNode); 
												try{
												 int order = 0;
												.)
		  KeyValue<order> [ comma 				(. order++; .)
		  					KeyValue<order> 
		  				  ]
		  										(.	}
												catch(ParseException & excp){
													if(shouldCloseANDNode) { 
														nsqlTree->clearNodeScope(andNode);
														shouldCloseANDNode = false;
													}
													else {
														nsqlTree->popNode();
													}
													delete andNode;
													throw;
												}
												if(shouldCloseANDNode) { 
														nsqlTree->closeNodeScope(andNode,true);
												}
												.)
												
	.
	
	KeyValue<int &order> =
												(.	EQNode *eq = new EQNode(EQ);
												bool shouldCloseEQ = true;
												nsqlTree->openNodeScope(eq);  
												try { 
												 	FieldNode *field = new FieldNode(FIELD);
												 	field->setName("PRIMARY");
												 	field->setPrimary(true);
												 	field->setPrimaryKeyOrder(order);
													nsqlTree->openNodeScope(field); 
													nsqlTree->closeNodeScope(field,true);
												.)
	
												(. char * value = NULL;.)
	(											
		Literal<value>							(. LiteralNode *literal = new LiteralNode(LITERAL);
		 										literal->setValue(value);
												nsqlTree->openNodeScope(literal); 
												nsqlTree->closeNodeScope(literal,true);  .)
												
		 | BindVariable<value>					(. BindNode *bind = new BindNode(BIND);
		 										bind->setName(value);
												nsqlTree->openNodeScope(bind); 
												nsqlTree->closeNodeScope(bind,true);.)
	)											(.	}
												catch(ParseException & excp){
													if(shouldCloseEQ) { 
														nsqlTree->clearNodeScope(eq);
														shouldCloseEQ = false;
													}
													else {
														nsqlTree->popNode();
													}
													delete eq;
													throw;
												}
												if(shouldCloseEQ) { 
														nsqlTree->closeNodeScope(eq,2);
												}
												.)
	.
	
	
	UniqueIndex = 
		"UNIQUE" "INDEX"
	.
// End of Backward compatibility

	SelectCondition
		= Expression
	.
	
	PrimaryExpression							(. char * value = NULL;.)
		=  Identifier<value> 					(. FieldNode *field = new FieldNode(FIELD);
												field->setName(value);
												nsqlTree->openNodeScope(field); 
												nsqlTree->closeNodeScope(field,true);.)
		 | 
		 										
		 Literal<value>							(. LiteralNode *literal = new LiteralNode(LITERAL);
		 										literal->setValue(value);
												nsqlTree->openNodeScope(literal); 
												nsqlTree->closeNodeScope(literal,true);  .)
												
		 | BindVariable<value>					(. BindNode *bind = new BindNode(BIND);
		 										bind->setName(value);
												nsqlTree->openNodeScope(bind); 
												nsqlTree->closeNodeScope(bind,true);.)
												
		 | Lparen Expression RParen
	.
	
	Lparen
		= "("									
	.
	
	RParen
		= ")"									
	.
	
	Literal<char* &v>
		=  number								(.	v = coco_string_create_char(t->val); .)
		| qstring 								(.	v = coco_string_create_char(t->val); .)
		
	.
	
	BindVariable<char * &value>								
		= "$" Identifier<value>
	.
	
	RelationalExpression
		= PrimaryExpression 
		 {
				">"   
												(.	GTNode *gt = new GTNode(GT);
												bool shouldCloseGT = true;
												nsqlTree->openNodeScope(gt);  
												try{ .)
				PrimaryExpression 
												(.	}
												catch(ParseException & excp){
													if(shouldCloseGT) { 
														nsqlTree->clearNodeScope(gt);
														shouldCloseGT = false;
													}
													else {
														nsqlTree->popNode();
													}
													delete gt;
													throw;
												}
												if(shouldCloseGT) { 
														nsqlTree->closeNodeScope(gt,2);
												} 
												.)
												
			|	">="  						
												(.	GTENode *gte = new GTENode(GTE);
												bool shouldCloseGTE = true;
												nsqlTree->openNodeScope(gte); 
												try{ 
												 .)
			PrimaryExpression
												(.	}
												catch(ParseException & excp){
													if(shouldCloseGTE) { 
														nsqlTree->clearNodeScope(gte);
														shouldCloseGTE = false;
													}
													else {
														nsqlTree->popNode();
													}
													delete gte;
													throw;
												}
												if(shouldCloseGTE) { 
														nsqlTree->closeNodeScope(gte,2);
												}
												.)
												
			|	"<"   
												(.	LTNode *lt = new LTNode(LT);
												bool shouldCloseLT = true;
												nsqlTree->openNodeScope(lt);
												try{   
												.)
			PrimaryExpression
												(.	}
												catch(ParseException & excp){
													if(shouldCloseLT) { 
														nsqlTree->clearNodeScope(lt);
														shouldCloseLT = false;
													}
													else {
														nsqlTree->popNode();
													}
													delete lt;
													throw;
												}
												if(shouldCloseLT) { 
														nsqlTree->closeNodeScope(lt,2);
												} 
												.)
												
			|	"<="  
												(.	LTENode *lte = new LTENode(LTE);
												bool shouldCloseLTE = true;
												nsqlTree->openNodeScope(lte); 
												try{ 
												.)
			PrimaryExpression
												(.	
												}
												catch(ParseException & excp){
													if(shouldCloseLTE) { 
														nsqlTree->clearNodeScope(lte);
														shouldCloseLTE = false;
													}
													else {
														nsqlTree->popNode();
													}
													delete lte;
													throw;
												}
												if(shouldCloseLTE) { 
														nsqlTree->closeNodeScope(lte,2);
												}
												.)
												
			|	"=="  
												(.	EQNode *eq = new EQNode(EQ);
												bool shouldCloseEQ = true;
												nsqlTree->openNodeScope(eq);  
												try { 
												.)
			PrimaryExpression
												(.	}
												catch(ParseException & excp){
													if(shouldCloseEQ) { 
														nsqlTree->clearNodeScope(eq);
														shouldCloseEQ = false;
													}
													else {
														nsqlTree->popNode();
													}
													delete eq;
													throw;
												}
												if(shouldCloseEQ) { 
														nsqlTree->closeNodeScope(eq,2);
												}
												.)
			|	"!="  
												(.	NEQNode *neq = new NEQNode(NEQ);
													bool shouldCloseNEQ = true;
												nsqlTree->openNodeScope(neq);
												try{
												 .)
			PrimaryExpression
												(.	}
												catch(ParseException & excp){
													if(shouldCloseNEQ) { 
														nsqlTree->clearNodeScope(neq);
														shouldCloseNEQ = false;
													}
													else {
														nsqlTree->popNode();
													}
													delete neq;
													throw;
												}
												if(shouldCloseNEQ) { 
														nsqlTree->closeNodeScope(neq,2);
												}
												.)
		 }
	.
	
	AndExpression
		= RelationalExpression
		 {
		  o_and 								(.	ANDNode *andNode = new ANDNode(AND);
		  											bool shouldCloseANDNode = true;
												nsqlTree->openNodeScope(andNode); 
												try{
												.)
		  RelationalExpression
		  										(.	}
												catch(ParseException & excp){
													if(shouldCloseANDNode) { 
														nsqlTree->clearNodeScope(andNode);
														shouldCloseANDNode = false;
													}
													else {
														nsqlTree->popNode();
													}
													delete andNode;
													throw;
												}
												if(shouldCloseANDNode) { 
														nsqlTree->closeNodeScope(andNode,2);
												}
												.)
		 }
		 								
	.
	
	OrExpression
		= AndExpression
		  {
			o_or 								(.	ORNode *orNode = new ORNode(OR);
													bool shouldCloseORNode = true;
												nsqlTree->openNodeScope(orNode);  
												try{ 
												.)
			AndExpression
												(.	}
												catch(ParseException & excp){
													if(shouldCloseORNode) { 
														nsqlTree->clearNodeScope(orNode);
														shouldCloseORNode = false;
													}
													else {
														nsqlTree->popNode();
													}
													delete orNode;
													throw;
												}
												if(shouldCloseORNode) { 
														nsqlTree->closeNodeScope(orNode,2);
												}
												.)
		  }
		  									
	.
	
	Expression
		= OrExpression
	.
	
	
END NSQL .